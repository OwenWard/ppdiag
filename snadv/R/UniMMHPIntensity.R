#' Return the intensity function of the Markov-modulated Hawkes Process(MMHP)
#'
#' Take a mmhp object and generate its intensity function accordingly
#'
#' @param mmhp a mmhp object including its state, state_time, tau, lambda0, lambda1, beta and alpha.
#' @param simulation the simulated Markov-modulated Hawkes Process(MMHP)

#' @export
#' @examples
#' Q = matrix(c(-0.4,0.4,0.2,-0.2),ncol = 2,byrow = TRUE)
#' x<-mmhp(Q, delta = c( 1/3, 2/3), lambda0 = 0.9, lambda1 = 1.1, alpha = 0.8, beta = 1.2)
#' y<-simulatemmhp(x)
#' z<-UniMMHPIntensity(x, y)
UniMMHPIntensity <- function (mmhp, simulation){
  # input mmhp: mmhp object generated by mmhp.R
  t <- simulation$tau
  state <- simulation$z
  state_time <- simulation$x
  lambda0 <- mmhp$lambda0
  lambda1 <- mmhp$lambda1
  alpha <- mmhp$alpha
  beta <- mmhp$beta
  n <- length(t)
  m <- length(state)
  intensity <- function(x){
    y<-0
    for(i in 1:(m-1)){
      if(state[i] == 1){
        hawkes_time <- t[t >= state_time[i] & t < state_time[i+1]]
        if(i == 1) hawkes_time <- hawkes_time[-1]
        history <- t[t < state_time[i]]
        HPfunc <- HPIntensity(lambda1, i, alpha, beta, state_time[i], state_time[i + 1], history[-1], hawkes_time)
        if(x>= state_time[i] & x<=state_time[i + 1]){
          y <- HPfunc(x)
        }
      }else{
        if(x>= state_time[i] & x<=state_time[i + 1]){
          y <- lambda0
        }
       }
    }
    return(y)


  }

  return(Vectorize(intensity))
}
