---
title: "Test Case of Existing Functions and `R` classes"
author: "Owen Ward"
date: "6/6/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The aim of this document is to demonstrate the existing functions in this package
and to use them to better understand how `S3` classes work in `R`.

To do this we will load in a simple univariate point process and analyse it using
the existing tools.

We will load in a simple event stream from an existing package.

```{r,echo=FALSE,message=FALSE}
library(tidyverse)
library(SAPP)

theme_set(theme_bw())
```

```{r}
data(Brastings)

Brastings %>% head(n=20)

length(Brastings)

range(Brastings)

events <- Brastings[1:100]

tibble(times=events,value = 1) %>%
  ggplot(aes(times,value)) + geom_point() + theme(axis.ticks = element_blank(),axis.text.y = element_blank()) 

```


# Fit a Homogeneous Poisson Process

The first thing we can do is fit a homogeneous Poisson process to `events`.

The MLE, $\hat{\lambda}$ is simply $M/T$, for $M$ events in a time period $T$.


```{r fit_hom_Pois}
lambda_hat <- length(events)/max(events)
lambda_hat

```

# Fit a Hawkes Process

We can also fit a Hawkes process using `optim`.

```{r hawkes_functions, include=FALSE}
uniHawkesCompensator<-function(lambda0,alpha,beta,t) {
  n<-length(t)
  delta.t<-t-c(0,t[-n])
  Lambda<-rep(0,n)
  A<-0
  Lambda[1]<-lambda0*(t[1])*2
  for(i in 2:n){
    A<-1+exp(-beta*(delta.t[i-1]))*A
    Lambda[i]<-lambda0*(delta.t[i])*2+alpha/beta(1-exp(-beta*delta.t[i]))*A
  }
  return(Lambda)
}
uniHawkesNegLogLik <- function(params=list(lambda0,alpha,beta), t) {
  lambda0 <- params[[1]]
  alpha <- params[[2]]
  beta <- params[[3]]
  n <- length(t)
  r <- rep(0,n)
  for(i in 2:n) {
    r[i] <- exp(-beta*(t[i]-t[i-1]))*(1+r[i-1])
  }
  loglik <- -t[n]*lambda0
  loglik <- loglik+alpha/beta*sum(exp(-beta*(t[n]-t))-1)
  if(any(lambda0+alpha*r<=0)){
    loglik<--1e+10 
  }else{
    loglik <- loglik+sum(log(lambda0+alpha*r))
  }
  return(-loglik)
}
uniHawkesntensity <- function(params=list(lambda0,alpha,beta), times, t0) {
  intens <- 0
  lambda0 <- params[[1]]
  alpha <- params[[2]]
  beta <- params[[3]]
  keep_times <- times[which(times < t0)]
  intens <- intens + lambda0 + alpha * sum(exp(-beta*(t0-keep_times)))
  return(intens)
}

Res_Hawkes <- function(params = list(lambda0,alpha,beta),times, t0) {
  lambda0 <- params[[1]]
  alpha <- params[[2]]
  beta <- params[[3]]
  tmp <- uniHawkesCompensator(lambda0,alpha,beta,times)
  n <- length(which(times < t0))
  return(n-sum(tmp))
}


```



We can fit a Hawkes process.

```{r}
hawkes.par<-optim(par=rep(0.01,3), fn=uniHawkesNegLogLik, 
                    t=events, control = list(maxit = 1000) )

# optim does minimization by default. the min of the negative loglikelihood
# is the max of the likelihood
hawkes.par$convergence
hawkes.par

```
We then want to use `hawkes.par$par to plot.


```{r}
drawHPIntensity(lambda0 = hawkes.par$par[1],alpha = hawkes.par$par[2],
                beta = hawkes.par$par[3],
                start = 0,
                end =  max(events),
                hawkes_time = events,
                history = events,
                i = 1)


```
This doesn't work because `drawHPIntensity` is currently only really built to
be used inside `drawUniMMHPIntensity`, which fits a more complex model. We
can use that on a simple example.


```{r}
Q <- matrix(c(-0.4, 0.4, 0.2, -0.2), ncol = 2, byrow = TRUE)
x <- mmhp(Q, delta = c(1 / 3, 2 / 3), 
          lambda0 = 0.2,
          lambda1 = .75,
          alpha = 1.8,
          beta = 1.2)
y <- simulatemmhp(x,nsim = 10)
drawUniMMHPIntensity(x, y)

```
This uses `drawHPIntensity` for some regions. Hence if you call it, it assumes it
is being added to an existing plot, hence the error.

- We can modify the hawkes plotting function so that it can be used on its own also. 
To do this we can have a function argument `ADD` which is false by default.
When it's false we initialise an empty plot with `plot`. We then set `ADD` to `TRUE`
when calling it inside the MMHP, so it will instead add to the existing plot. 
- Sally, this might be something simple for you to do initially by creating a branch,
editing the functions as required and submitting a pull request.

# Residuals

We can compute the Pearson and raw residuals for multiple models which
are documented in those files. Lets implement the ones we have.






