---
title: "Test Case of Existing Functions and `R` classes"
author: "Owen Ward"
date: "6/6/2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The aim of this document is to demonstrate the existing functions in this package
and to use them to better understand how `S3` classes work in `R`.

To do this we will load in a simple univariate point process and analyse it using
the existing tools.

We will load in a simple event stream from an existing package.

```{r,echo=FALSE,message=FALSE}
library(tidyverse)
library(SAPP)

theme_set(theme_bw())
```

```{r}
data(Brastings)

Brastings %>% head(n=20)

length(Brastings)

range(Brastings)

events <- Brastings[1:20]

tibble(times=events,value = 1) %>%
  ggplot(aes(times,value)) + geom_point() + theme(axis.ticks = element_blank(),axis.text.y = element_blank()) 

```


# Fit a homogeneous Poisson process

The first thing we can do is fit a homogeneous Poisson process to `events`.

The MLE, $\hat{\lambda}$ is simply $M/T$, for $M$ events in a time period $T$.


```{r fit_hom_Pois}
lambda_hat <- length(events)/max(events)
lambda_hat

```

# Fit a Hawkes process

We can also fit a Hawkes process using `optim`.

```{r hawkes_functions, include=FALSE}
uniHawkesCompensator<-function(lambda0,alpha,beta,t) {
  n<-length(t)
  delta.t<-t-c(0,t[-n])
  Lambda<-rep(0,n)
  A<-0
  Lambda[1]<-lambda0*(t[1])*2
  for(i in 2:n){
    A<-1+exp(-beta*(delta.t[i-1]))*A
    Lambda[i]<-lambda0*(delta.t[i])*2+alpha/beta(1-exp(-beta*delta.t[i]))*A
  }
  return(Lambda)
}
uniHawkesNegLogLik <- function(params=list(lambda0,alpha,beta), t) {
  lambda0 <- params[[1]]
  alpha <- params[[2]]
  beta <- params[[3]]
  n <- length(t)
  r <- rep(0,n)
  for(i in 2:n) {
    r[i] <- exp(-beta*(t[i]-t[i-1]))*(1+r[i-1])
  }
  loglik <- -t[n]*lambda0
  loglik <- loglik+alpha/beta*sum(exp(-beta*(t[n]-t))-1)
  if(any(lambda0+alpha*r<=0)){
    loglik<--1e+10 
  }else{
    loglik <- loglik+sum(log(lambda0+alpha*r))
  }
  return(-loglik)
}
uniHawkesntensity <- function(params=list(lambda0,alpha,beta), times, t0) {
  intens <- 0
  lambda0 <- params[[1]]
  alpha <- params[[2]]
  beta <- params[[3]]
  keep_times <- times[which(times < t0)]
  intens <- intens + lambda0 + alpha * sum(exp(-beta*(t0-keep_times)))
  return(intens)
}

Res_Hawkes <- function(params = list(lambda0,alpha,beta),times, t0) {
  lambda0 <- params[[1]]
  alpha <- params[[2]]
  beta <- params[[3]]
  tmp <- uniHawkesCompensator(lambda0,alpha,beta,times)
  n <- length(which(times < t0))
  return(n-sum(tmp))
}


```



We can fit a Hawkes process.

```{r}
hawkes.par<-optim(par=rep(0.01,3), fn=uniHawkesNegLogLik, 
                    t=events, control = list(maxit = 1000),lower = c(1e-4,1e-4,1e-4),
                  method = "L-BFGS-B")

# optim does minimization by default. the min of the negative loglikelihood
# is the max of the likelihood
hawkes.par$convergence
hawkes.par

```

Note that there is actually a `negloglik` function which I could/should have used here. 

- A simple task would be to redo this MLE calculation using that function.

We then want to use `hawkes.par$par to plot.




```{r, error=TRUE}
devtools::load_all() # to load in the package we are working on


hawkes_par <- list(lambda0 = 0.5,alpha=0.1,
                   beta = hawkes.par$par[3])
hawkes_max_intensity(hawkes_par,events[1:10])


drawHPIntensity(lambda0 = 0.01,alpha = 0.21,
                beta = 0.5,
                start = 0,
                end =  max(events[1:10]),
                hawkes_time = events[1:10],
                history = NULL,
                i = 1)
drawHPIntensity(lambda0 = 0.01,alpha = 0.21,
                beta = 0.5,
                start = 0,
                end =  max(events[1:10]),
                hawkes_time = events[1:10],
                history = NULL,
                i = 0)

```
This doesn't work because `drawHPIntensity` is currently only really built to
be used inside `drawUniMMHPIntensity`, which fits a more complex model. We
can use that on a simple example.


```{r}
Q <- matrix(c(-0.4, 0.4, 0.2, -0.2), ncol = 2, byrow = TRUE)
x <- mmhp(Q, delta = c(1 / 3, 2 / 3), 
          lambda0 = 0.2,
          lambda1 = .75,
          alpha = 1.8,
          beta = 1.2)
y <- simulatemmhp(x,nsim = 10)
drawUniMMHPIntensity(x, y)

```

This uses `drawHPIntensity` for some regions. Hence if you call it, it assumes it
is being added to an existing plot, hence the error.

- We can modify the hawkes plotting function so that it can be used on its own also. 
To do this we can have a function argument `ADD` which is false by default.
When it's false we initialise an empty plot with `plot`. We then set `ADD` to `TRUE`
when calling it inside the MMHP, so it will instead add to the existing plot. 
- Sally, this might be something simple for you to do initially by creating a branch,
editing the functions as required and submitting a pull request.

# Residuals

We can compute the Pearson and raw residuals for multiple models which
are documented in those files. Lets implement the ones we have.

## Raw residuals

```{r, error=TRUE}

hp_object <- list(lambda0 = hawkes.par$par[1],
                  alpha = hawkes.par$par[2],
                  beta = hawkes.par$par[3])



rawresidual.hp(hp_object,t = events,termination = max(events))

# if you make hp_object a hawkes process object then you can just call
# rawresidual instead.
# this is to do with S3 classes
class(hp_object) <- "hp"

rawresidual(hp_object,t = events, termination = max(events))

# won't work for a class that hasn't been defined in rawresidual.R
class(hp_object) <- "p"

rawresidual(hp_object,t = events, termination = max(events))


```

## Pearson residuals

```{r,error=TRUE}
class(hp_object) <- "hp"
pearsonresidual(hp_object,t = events, termination = max(events))

class(hp_object) <- "p"
pearsonresidual(hp_object,t = events, termination = max(events))


```
Note that this gives a different error message to the same
error in raw residuals. We would like these
messages to be uniform across all object types.

- Sally, this is something else which should be pretty straightforward to
fix, another early task which could be good to work through.
- Based on the message, it seems the error has not been defined for 
the `pearsonresidual`.





