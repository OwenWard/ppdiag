---
title: "PPDiag"
output:
  html_document:
    toc: true
    toc_float: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
devtools::load_all()  ## loads ppdiag
```
# Load data
We'll apply some data to the functions. 
```{r}
time=readRDS("time.RDS")
```

# Homogeneous Poisson Process

## Class
hpp(lambda, start=0, end=1, n = NULL) takes lambda(rate of the poisson process), start and end(start and end time of events), n(number of events) as inputs and returns an object of class hpp, in the form of a list of parameters provided. 
```{r}
pois_y <- hpp(lambda = 1, end = 10)

pois_y
```


## Simulate
simulatehpp takes a hpp object in the form of a list(lambda, start=0, end=1, n = NULL) and simulates events according to the arguments in the list, this function returns a vector of event times. 
```{r}
# events <- simulatehpp(lambda = 1, end = 10)
# events

pois_y$n <- 50
events <- simulatehpp(pois_y)
events
```


Below are several examples simulations(10 events, 50 events, and 100 events), their histogram of interevent times and the corresponding fitted density curves are plotted to illustrate homogeneous poisson events. 
```{r}
# sample simulation of 10 hpp events
s1=simulatehpp(hpp(lambda=1,n=10))
inter_s1=diff(s1)
hist(inter_s1,main="interevent times",freq=FALSE)
lines(density(inter_s1))

# sample simulation of 50 hpp events
s2=simulatehpp(hpp(lambda=3,n=50))
inter_s2=diff(s2)
hist(inter_s2,main="interevent times",freq=FALSE)
lines(density(inter_s2))

# sample simulation of 100 hpp events
s3=simulatehpp(hpp(lambda=1,n=100))
inter_s3=diff(s3)
hist(inter_s3,main="interevent times",freq=FALSE)
lines(density(inter_s3))
```

## Fit
fithpp takes a vector of events and returns a hpp object in the form of list(lambda, start, end, n), events are fitted according to the maximum likelihood estimator.
```{r}

fithpp(events)

fit_hpp <- fithpp(events)

```
Then we try to fit the time data:
```{r}
time_fit_hpp=fithpp(time)
time_fit_hpp
```

## Plot
plothpp_step takes in a vector of event times, a color parameter, and plots the event time counts.
```{r}
plothpp_step(events)
```

Let's plot the time data:
```{r}
plothpp_step(time)
```

To draw the homogeneous poisson process, use
`drawHPPIntensity takes (hpp, events = NULL, color = "red", 
plot_events = FALSE,fit = FALSE,int_title = "Intensity homogeneous Poisson Process")`,
which include a necessary argument which is a hpp object, and plots its intensity. You can also input 'events', which is a vector of event times, and indicate whether to plot the given events in 'plot_events', and indicate whether to fit a hpp on the given events or use the given hpp object in 'fit'.
```{r}
drawHPPIntensity(pois_y,color = "red")

# this plots the fit_hpp intensity and its corresponding simulated events, since plot_events default is FALSE:
drawHPPIntensity(fit_hpp,events=events, color = "red")

# this plots the inputted events, since plot_events=TRUE:
drawHPPIntensity(fit_hpp, events=events, color = "red", plot_events=TRUE)
```
Then we plot the intensity of the fitted time data:
```{r}
# this plots the fit_hpp intensity and its corresponding simulated events, since plot_events default is FALSE:
drawHPPIntensity(time_fit_hpp,events=time, color = "red")

# this plots the inputted events, since plot_events=TRUE:
drawHPPIntensity(time_fit_hpp, events=time, color = "red", plot_events=TRUE)
```
## Diagnostics
diagpp takes a hpp object and a vector of events, and provides diagnostics of the model, including a qq plot, a ks plot, ks test, raw and pearson residuals. 
```{r}
diagpp(pois_y,t=events)
```

Applying time data:
```{r}
diagpp(time_fit_hpp,t=time)
```

#This gives the right warning message, but we don't want to simulate data for
#these plots.

Intensityqqplot takes a hpp object, and a vector of events, and plots the qqplot and intensity plot together. 
```{r}
intensityqqplot(object=fit_hpp,events = events, color="red")
```
Applying time data:
```{r}
intensityqqplot(object=time_fit_hpp,events = time)
```

## interevent times
Below is a histogram with fitted density of interevent times of our simulated events. 
```{r}
inter_hpp=diff(events)
hist(inter_hpp,freq=FALSE)
lines(density(inter_hpp))
```
For the time data:
```{r}
inter_hpp=diff(time)
hist(inter_hpp,freq=FALSE)
lines(density(inter_hpp))
```

# Hawkes Process

## Class
`hp(lambda0, alpha, beta, events = NULL)` takes lambda0(base intensity of hawkes process), alpha(jump size of increase in intensity), beta(exponential decay of intensity), events(the first event is at time zero, events data can be added later after simulation) as inputs and returns an object of class hp, in the form of a list of parameters provided.
```{r}
hp_obj <- hp(lambda0 = 0.1,alpha = 0.45,beta = 0.5)
```

## Simulate
`simulatehp` takes a hp object in the form of a list(hp, start=0, end, history=0) and simulates events according to the arguments in the list, this function returns a vector of event times. 
```{r}
sims <- simulatehp(hp_obj,start = 0, end = 100, history = 0)
sims
```

## Fit
`fithp` takes argument including vec, which is the vector of initial parameters lambda0, alpha, beta, and t, the vector of event times, and end, the end time of event times, and fits a hawkes process based on optimizing negative log likelihood, then returns a hp object in the form of a list that consists of the three parameters fitted. 
```{r}
init=rep(0.1,3)

fithp(init,sims$t,max(sims$t))

fit_hp <- fithp(init,sims$t,max(sims$t))
```
We can fit our time data to hp:
```{r}
init=rep(0.1,3)
time_fit_hp <- fithp(init,time,max(time))
time_fit_hp
```

## Plot

One difficulty with this is that now we cannot look at the fits for different
parameter values....

`drawHPIntensity takes (hp_obj, start, end, history=0, events,
                            color = 1, i = 1, add=FALSE, fit=FALSE,
                            plot_events=FALSE, vec=NULL, 
                            int_title="Hawkes Intensity")`,
which include necessary arguments including a hp object, events, and start and end time of events, and plots the intensity. You can also indicate whether to plot the given events in 'plot_events', and indicate whether to fit a hp on the given events or use the given hpp object in 'fit'.
```{r}
# changing this to use hawkes event times

drawHPIntensity(hp_obj, start=0, end=max(sims$t), history=0, events = sims$t,
                plot_events = TRUE)

drawHPIntensity(fit_hp, start=0, end=max(sims$t), 
                history=0, events = sims$t, plot_events = TRUE)

```

We can plot the hp intensity for the fitted time data:
```{r}
drawHPIntensity(time_fit_hp, start=min(time), end=max(time), history=0, events=time)
```

## Diagnostics
`diagpp` takes a hp object and a vector of events, and provides diagnostics of the model, including a qq plot, a ks plot, ks test, raw and pearson residuals. 
```{r}
diagpp(hp_obj, t=sims$t)
# this is the truth


diagpp(fit_hp, t = sims$t)

```

Applying diagnostics on the time data:
```{r}
diagpp(time_fit_hp, t = time)
```

`intensityqqplot` takes a hp object, a vector of events,
its start and end time, an optional argument of historical events, and plots the 
qqplot and intensity plot together. 
```{r}
intensityqqplot(fit_hp,start=0,end=max(sims$t),events=events)
```

Plotting intensityqqplot for the time data:
```{r}
intensityqqplot(time_fit_hp,start=min(time),end=max(time),events=time)
```

## interevent times
Below is a plot of interevent times of our simulated events. 
```{r}
temp=sims$t
inter_hp=sims$t[2:length(sims$t)]-temp[1:length(temp)-1]
hist(inter_hp,freq=FALSE)
lines(density(inter_hp))
```

# MMHP
## Class
`mmhp(lambda0, lambda1, alpha, beta, Q = NULL, delta = NULL, events = NULL)`
takes lambda0(intensity for hpp), lambda1(base intensity for hp), alpha(jump size
of the increase in intensity in hp), beta(exponential decrease of intensity in 
hp), Q(transition probability matrix), delta(initial state probability), 
events(event times, could be added later after simulation) as inputs and returns 
an object of class mmhp, in the form of a list of parameters provided.

```{r}
Q <- matrix(c(-0.4, 0.4, 0.2, -0.2), ncol = 2, byrow = TRUE)

x <- mmhp(Q, delta = c(1 / 3, 2 / 3), 
          lambda0 = 0.2,
          lambda1 = .75,
          alpha = 0.1,
          beta = 0.2)
```

## Simulate
`simulatemmhp(object, n = 1, given_state = FALSE, 
states = NULL, seed = NULL, 
...)`
takes a mmhp object, n which is number of events, given_state which is a boolean 
parameter, If TRUE, then simulate according to the given state, default FALSE, 
states which is an object containing z, the states of Markov Process, x, time of 
each transition of Markov process, ending, preset ending time for the process, 
and seed which is the seed of the random number generator. It returns a simulated
Markov Modulated Hawkes Process, including states of Markov Process, time of each
transition of Markoc Process, state at each event, times of Poisson events.
```{r}
y <- simulatemmhp(x,n = 50)
```

`drawUniMMHPIntensity(mmhp, simulation, add = FALSE, color = 1, given_main = "Intensity Plot of MMHP")`
takes a mmhp object, mmhp which is the simulated mmhp events, add which is a logical parameter, if TRUE add to an already existing plot, if NA start a new plot taking the defaults for the limits and log-scaling of the x-axis from the previous plot, taken as FALSE (with a warning if a different value is supplied) if no graphics device is open, color which is the default plotting color, given_main which is the title of the plot. It plots the intensity of mmhp. 
## Plot
```{r}
drawUniMMHPIntensity(x, y)
```

## Diagnostics
`diagpp` takes a mmhp object and a vector of events, and provides diagnostics of the model, including a qq plot, a ks plot, ks test, raw and pearson residuals. 
```{r}
try(diagpp(x, t=y$events))
```
`intensityqqplot` takes a mmhp object, start and end time, vector of historical events, a vector of events, a state jump directly before, an optional argument of historical events, probability for calculating rescaled-interevent times, and plots the qqplot and intensity plot together. 
```{r}
intensityqqplot(object=x,simulation=y, events=y$events,pzt=0.5)
```
